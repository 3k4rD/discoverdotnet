//#n Wyam.Yaml
//#n Wyam.Razor
//#n Wyam.Markdown
//#n Wyam.Json
//#n Wyam.Sass
//#n Wyam.Minification

#n Octokit
#n AngleSharp

using System.Collections.Concurrent;
using System.Threading.Tasks;
using System.Net;
using Octokit;
using AngleSharp;

//////////////////////////////////////////////////////////////////////
// Pipelines
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Projects",
    ReadFiles("projects/*.md"),
    FrontMatter(Yaml()),    
    Execute((inputs, ctx, _) => GetProjectGitHubData(inputs, ctx).Result),
    Execute((inputs, ctx, _) => GetProjectNuGetData(inputs, ctx).Result),
    Meta("Key", (doc, ctx) => doc.Source.FileNameWithoutExtension.FullPath),
    Razor()
        .WithLayout("/projects/_Layout.cshtml"),
    WriteFiles(".html"),
    Meta("Link", (doc, ctx) => ctx.GetLink(doc)),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Link",
        "Description",
        "StargazersCount",
        "ForksCount",
        "OpenIssuesCount",
        "PushedAt",
        "Website",
        "Language",
        "Tags",
        "DiscoveryDate",
        "Comment",
        "Platform",
        "Microsoft",
        "Foundation"
    ))
);

Pipelines.Add("Project Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Projects").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/projects.json")
);

Pipelines.Add("Project Keys",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Projects")
            .Select(x => x.GetMetadata(
                "Key",
                "Title",
                "Link")))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/project-keys.json")
);

Pipelines.Add("Discoveries",
    Documents("Projects"),
    // TODO: Add other pipelines of discoverable items
    Where(@doc.ContainsKey("DiscoveryDate")),
    OrderBy(@doc.DateTime("DiscoveryDate"))
        .Descending(),
    GenerateJson((doc, ctx) => doc["CardData"])
        .WithCamelCase(),
    MinifyJs(),
    Branch(
        // Daily discovery
        Take(1),
        WriteFiles((doc, ctx) => "data/discovery.json")
    )
    // Past discoveries
    // TODO: skip 1, take 4 (or 8?)
    // TODO: RSS feed
);

Pipelines.Add("Pages",
    ReadFiles("**/{!_,}*.cshtml"),
    FrontMatter(Yaml()),
    Razor()
        .WithLayout("/_Layout.cshtml"),
    WriteFiles(".html")
);

Pipelines.Add("Sass",
    ReadFiles("**/{!_,}*.scss"),
    Sass()
        .WithCompactOutputStyle(),
    WriteFiles()
);

Pipelines.Add("Resources",
    CopyFiles("**/*{!.cshtml,!.md,!.less,!.yml,!.scss,}")
);

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

public async Task<IEnumerable<IDocument>> GetProjectGitHubData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{            
    string[] microsoftOwners = new []
    {
        "dotnet",
        "aspnet",
        "microsoft",
        "nuget",
        "mono",
        "azure"
    };

    GitHubClient github = new GitHubClient(new ProductHeaderValue("discoverdotnet"))
    {
        Credentials = new Credentials(context.String("GitHubToken"))
    };
    DateTimeOffset oneDayAgo = DateTimeOffset.Now.AddHours(-24);

    Wyam.Common.Tracing.Trace.Information($"Getting .NET Foundation readme");
    string foundationReadme;
    using(System.Net.WebClient webClient = new System.Net.WebClient())
	{
		foundationReadme = await webClient.DownloadStringTaskAsync("https://raw.githubusercontent.com/dotnet/home/master/README.md");
	}

    return await Task.WhenAll(
        inputs.Select(async input =>
        {
            // Extract the GitHub owner and name
            Uri source;
            if(Uri.TryCreate(input.String("Source"), UriKind.Absolute, out source)
                && source.Host.EndsWith("github.com", StringComparison.OrdinalIgnoreCase))
            {
                string owner = source.Segments[1].Trim('/');
                string name = source.Segments[2].Trim('/');

                // Connect to GitHub and get the repository
                Wyam.Common.Tracing.Trace.Information($"Getting GitHub data for {owner}/{name}");
                Repository repository = await github.Repository.Get(owner, name);

                // Get the metadata
                MetadataItems metadata = new MetadataItems
                {
                    { "StargazersCount", repository.StargazersCount },
                    { "ForksCount", repository.ForksCount },
                    { "OpenIssuesCount", repository.OpenIssuesCount },
                    { "PushedAt", repository.PushedAt },
                    { "CreatedAt", repository.CreatedAt }
                };
                if(!input.ContainsKey("Title"))
                {
                    metadata.Add("Title", repository.Name);
                }
                if(!input.ContainsKey("Description"))
                {
                    metadata.Add("Description", repository.Description);
                }
                if(!input.ContainsKey("Website"))
                {
                    metadata.Add("Website", repository.Homepage);
                }
                if(!input.ContainsKey("Microsoft") && microsoftOwners.Contains(owner, StringComparer.OrdinalIgnoreCase))
                {
                    metadata.Add("Microsoft", true);
                }
                if(!input.ContainsKey("Foundation") && foundationReadme.IndexOf($"github.com/{owner}/{name}", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    metadata.Add("Foundation", true);
                }

                // Get the readme
                Wyam.Common.Tracing.Trace.Information($"Getting GitHub readme for {owner}/{name}");
                string readme = await github.Repository.Content.GetReadmeHtml(owner, name);
                if(!string.IsNullOrEmpty(readme))
                {
                    metadata.Add("Readme", readme);
                }                

                // Report on out API rate limit
                MiscellaneousRateLimit rateLimit = await github.Miscellaneous.GetRateLimits();
                Wyam.Common.Tracing.Trace.Information($"GitHub rate limit: {rateLimit.Resources.Core.Remaining} remaining");

                // Return a document with GitHub metadata
                return context.GetDocument(input, metadata);
            }

            return input;
        }));
}

public async Task<IEnumerable<IDocument>> GetProjectNuGetData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{
    AngleSharp.IConfiguration config = AngleSharp.Configuration.Default.WithDefaultLoader();
    
    return await Task.WhenAll(
        inputs.Select(async input =>
        {
            string package = input.String("NuGet");
            if(!string.IsNullOrEmpty(package))
            {
                Wyam.Common.Tracing.Trace.Information($"Getting NuGet data for {package}");
                IBrowsingContext browsingContext = BrowsingContext.New(config);
	            AngleSharp.Dom.IDocument document = await browsingContext.OpenAsync($"https://www.nuget.org/packages/{package}");
                if(document != null)
                {
                    // Get statistics
                    AngleSharp.Dom.IElement statistics = document
                        .QuerySelectorAll(".package-details-info h2")
                        .First(x => x.TextContent == "Statistics")
                        .NextElementSibling;
                    string totalDownloads = statistics.Children
                        .First(x => x.TextContent.Contains("total downloads"))
                        .TextContent.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[0];
                    string latestVersionDownloads = statistics.Children
                        .First(x => x.TextContent.Contains("latest version"))
                        .TextContent.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[0];
                    string perDayDownloads = statistics.Children
                        .First(x => x.TextContent.Contains("per day"))
                        .TextContent.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[0];

                    // Get versions
                    List<VersionData> versions = document
			            .QuerySelectorAll("#version-history table tbody tr")
                        .Select(x => new VersionData(x))
                        .ToList();
                    
                    // Return a document with NuGet data
                    return context.GetDocument(input, new MetadataItems
                    {
                        { "TotalDownloads", totalDownloads },
                        { "LatestVersionDownloads", latestVersionDownloads },
                        { "PerDayDownloads", perDayDownloads },
                        { "LatestVersion", versions.First().Version },                        
                        { "LatestVersionLastUpdated", versions.First().LastUpdated },
                        { "Versions", versions }
                    });
                }
            }

            return input;
        }));
}

public class VersionData
{
    public string Version { get; }
    public string Downloads { get; }
    public DateTime LastUpdated { get; }

    public VersionData(AngleSharp.Dom.IElement element)
    {
        Version = element.Children[0].TextContent.Replace("(current version)", string.Empty).Trim();
        Downloads = element.Children[1].TextContent;
        LastUpdated = DateTime.Parse(element.Children[2].FirstElementChild.GetAttribute("data-datetime"));
    }
}