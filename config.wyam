//#n Wyam.Yaml
//#n Wyam.Razor
//#n Wyam.Markdown
//#n Wyam.Json
//#n Wyam.Sass
#n Octokit

using System.Collections.Concurrent;
using System.Threading.Tasks;
using Octokit;

Pipelines.Add("Projects",
    ReadFiles("projects/*.md"),
    FrontMatter(Yaml()),    
    Execute((inputs, ctx, _) => GetProjectGitHubData(inputs, ctx).Result),
    Razor()
        .WithLayout("/projects/_Layout.cshtml"),
    WriteFiles(".html"),
    Meta("Link", @ctx.GetLink(@doc)),
    GenerateJson(new []
    {
        "Title",
        "Link",
        "Description",
        "StargazersCount",
        "ForksCount",
        "OpenIssuesCount",
        "PushedAt",
        "Website",
        "Language",
        "Tags",
        "DiscoveryDate",
        "Comment",
        "RecentIssuesCount",
        "HelpWantedIssuesCount"
    }, "Json")
        .WithCamelCase()
);

Pipelines.Add("ProjectsData",
    Content("[" + string.Join(",", @ctx.Documents.FromPipeline("Projects").Select(x => x.String("Json"))) + "]"),
    WriteFiles((doc, ctx) => "data/projects.json")
);

Pipelines.Add("Discoveries",
    Documents("Projects"),
    Where(@doc.ContainsKey("DiscoveryDate")),
    OrderBy(@doc.DateTime("DiscoveryDate"))
        .Descending(),
    Content(@doc.String("Json")),
    Branch(
        // Daily discovery
        Take(1),
        WriteFiles((doc, ctx) => "data/discovery.json")
    )
    // Past discoveries
    // TODO: skip 1, take 4 (or 8?)
    // TODO: RSS feed
);

Pipelines.Add("Pages",
    ReadFiles("**/{!_,}*.cshtml"),
    FrontMatter(Yaml()),
    Razor()
        .WithLayout("/_Layout.cshtml"),
    WriteFiles(".html")
);

Pipelines.Add("Sass",
    ReadFiles("**/{!_,}*.scss"),
    Sass()
        .WithCompactOutputStyle(),
    WriteFiles()
);

Pipelines.Add("Resources",
    CopyFiles("**/*{!.cshtml,!.md,!.less,!.yml,!.scss,}")
);

// Helper classes and methods

public class IssueData
{
    public static string[] HelpWantedLabels = new []
    {
        "helpwanted",
        "goodfirstissue",
        "firsttimersonly",
        "upforgrabs",
        "newcontributor",
        "goodfirsttask"
    };

    public DateTimeOffset CreatedAt { get; }
    public DateTimeOffset UpdatedAt { get; }
    public string Link { get; }
    public string Title { get; }
    public string[] Labels { get; }

    public IssueData(Issue issue)
    {
        CreatedAt = issue.CreatedAt;
        UpdatedAt = issue.UpdatedAt ?? issue.CreatedAt;
        Link = issue.HtmlUrl;
        Title = issue.Title;
        Labels = issue.Labels.Select(x => x.Name).ToArray();
    }
}

public async Task<IEnumerable<IDocument>> GetProjectGitHubData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{            
    GitHubClient github = new GitHubClient(new ProductHeaderValue("discoverdotnet"))
    {
        Credentials = new Credentials(context.String("GitHubToken"))
    };
    DateTimeOffset oneDayAgo = DateTimeOffset.Now.AddHours(-24);

    return await Task.WhenAll(
        inputs.Select(async input =>
        {
            // Extract the GitHub owner and name
            Uri source;
            if(Uri.TryCreate(input.String("Source"), UriKind.Absolute, out source)
                && source.Host.EndsWith("github.com", StringComparison.OrdinalIgnoreCase))
            {
                string owner = source.Segments[1].Trim('/');
                string name = source.Segments[2].Trim('/');

                // Connect to GitHub and get the repository
                Wyam.Common.Tracing.Trace.Information($"Getting GitHub data for {owner}/{name}");
                Repository repository = await github.Repository.Get(owner, name);

                // Get the metadata
                MetadataItems metadata = new MetadataItems
                {
                    { "Owner", owner },
                    { "StargazersCount", repository.StargazersCount },
                    { "ForksCount", repository.ForksCount },
                    { "OpenIssuesCount", repository.OpenIssuesCount },
                    { "PushedAt", repository.PushedAt }
                };
                if(!input.ContainsKey("Title"))
                {
                    metadata.Add("Title", repository.Name);
                }
                if(!input.ContainsKey("Description"))
                {
                    metadata.Add("Description", repository.Description);
                }
                if(!input.ContainsKey("Website"))
                {
                    metadata.Add("Website", repository.Homepage);
                }

                // Get the readme
                Wyam.Common.Tracing.Trace.Information($"Getting GitHub readme for {owner}/{name}");
                string readme = await github.Repository.Content.GetReadmeHtml(owner, name);
                if(!string.IsNullOrEmpty(readme))
                {
                    metadata.Add("Readme", readme);
                }

                // Get issue data
                Wyam.Common.Tracing.Trace.Information($"Getting GitHub issue data for {owner}/{name}");
                IReadOnlyList<Issue> issues = await github.Issue.GetAllForRepository(
                    owner,
                    name,
                    new RepositoryIssueRequest
                    {
                        Filter = IssueFilter.All
                    },
                    new ApiOptions
                    {
                        PageSize = 100
                    });
                if(issues.Count > 0)
                {
                    IssueData[] issueData = issues.Select(x => new IssueData(x)).ToArray();
                    metadata.Add("Issues", issueData);

                    // Also add special issue counts
                    
                    metadata.Add("RecentIssuesCount", issueData.Count(x => x.CreatedAt > oneDayAgo));

                    int helpWantedIssuesCount = issueData.Count(x => x.Labels
                        .Select(l => new string(l.Where(c => char.IsLetterOrDigit(c)).ToArray()))
                        .Any(l => IssueData.HelpWantedLabels.Contains(l, StringComparer.OrdinalIgnoreCase)));
                    if(helpWantedIssuesCount > 0)
                    {
                        metadata.Add("HelpWantedIssuesCount", helpWantedIssuesCount);
                    }
                }                    

                // Report on out API rate limit
                MiscellaneousRateLimit rateLimit = await github.Miscellaneous.GetRateLimits();
                Wyam.Common.Tracing.Trace.Information($"GitHub rate limit: {rateLimit.Resources.Core.Remaining} remaining");

                // Return a document with GitHub metadata
                return context.GetDocument(input, metadata);
            }

            return input;
        }));
}